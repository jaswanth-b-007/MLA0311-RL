import random
import math
import matplotlib.pyplot as plt

# -----------------------------
# Environment settings
# -----------------------------
MAP_WIDTH = 100
MAP_HEIGHT = 100

START = (5, 5)
GOAL = (90, 90)

STEP_SIZE = 3
GOAL_THRESHOLD = 5
MAX_ITER = 5000

# Obstacles: (x, y, radius)
OBSTACLES = [
    (30, 30, 10),
    (60, 40, 8),
    (50, 70, 10),
    (20, 80, 6)
]

# -----------------------------
# Utility functions
# -----------------------------
def distance(p1, p2):
    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)

def collision(point):
    for (ox, oy, r) in OBSTACLES:
        if distance(point, (ox, oy)) <= r:
            return True
    return False

def steer(from_node, to_point):
    theta = math.atan2(to_point[1] - from_node[1],
                       to_point[0] - from_node[0])
    new_x = from_node[0] + STEP_SIZE * math.cos(theta)
    new_y = from_node[1] + STEP_SIZE * math.sin(theta)
    return (new_x, new_y)

def nearest_node(tree, point):
    return min(tree, key=lambda node: distance(node, point))

# -----------------------------
# RRT Algorithm
# -----------------------------
tree = [START]
parent = {START: None}
goal_reached = False

for i in range(MAX_ITER):
    rand_point = (random.uniform(0, MAP_WIDTH),
                  random.uniform(0, MAP_HEIGHT))

    nearest = nearest_node(tree, rand_point)
    new_node = steer(nearest, rand_point)

    if not collision(new_node):
        tree.append(new_node)
        parent[new_node] = nearest

        if distance(new_node, GOAL) < GOAL_THRESHOLD:
            parent[GOAL] = new_node
            tree.append(GOAL)
            goal_reached = True
            print("Goal reached!")
            break

# -----------------------------
# Path extraction
# -----------------------------
path = []
if goal_reached:
    node = GOAL
    while node is not None:
        path.append(node)
        node = parent[node]
    path.reverse()

# -----------------------------
# Visualization
# -----------------------------
plt.figure(figsize=(8, 8))

# Draw obstacles
for (ox, oy, r) in OBSTACLES:
    circle = plt.Circle((ox, oy), r, color='red')
    plt.gca().add_patch(circle)

# Draw RRT tree
for node in tree:
    if parent[node] is not None:
        px, py = parent[node]
        plt.plot([node[0], px], [node[1], py], color='gray', linewidth=0.5)

# Draw path
if goal_reached:
    px = [p[0] for p in path]
    py = [p[1] for p in path]
    plt.plot(px, py, color='blue', linewidth=3, label="Final Path")

# Draw start & goal
plt.scatter(*START, color='green', s=100, label='Start')
plt.scatter(*GOAL, color='purple', s=100, label='Goal')

plt.xlim(0, MAP_WIDTH)
plt.ylim(0, MAP_HEIGHT)
plt.title("RRT-based Autonomous Robot Exploration")
plt.legend()
plt.grid(True)
plt.show()
